{
  "name": "Tennis Buddy - Court Availability Monitor",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "secondsInterval": 30
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [
        200,
        200
      ],
      "notes": "Runs every 30 minutes continuously"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "tennis-commands",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "discord-webhook",
      "name": "Discord Commands Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        200,
        400
      ],
      "webhookId": "tennis-commands-webhook",
      "notes": "Handles Discord slash commands"
    },
    {
      "parameters": {
        "url": "https://www.sudarena.ro/rezervari",
        "options": {
          "headers": {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
          },
          "timeout": 30000,
          "retry": {
            "enabled": true,
            "maxTries": 3,
            "waitBetweenTries": 2000
          }
        }
      },
      "id": "scrape-courts",
      "name": "Scrape Tennis Courts",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        400,
        200
      ],
      "notes": "Fetches court availability from Sudarena website"
    },
    {
      "parameters": {
        "jsCode": "// Parse HTML and extract all available court data\nconst cheerio = require('cheerio');\nconst moment = require('moment-timezone');\n\n// Set timezone for Romania\nmoment.tz.setDefault('Europe/Bucharest');\n\nconst htmlContent = $input.first().json.data;\nconst $ = cheerio.load(htmlContent);\n\n// Initialize results array\nconst availableCourts = [];\nconst currentTime = moment();\n\n// Parse court availability (adapt selectors based on actual website structure)\ntry {\n  // Look for elements containing court information\n  $('.court-slot, .booking-slot, .time-slot').each(function() {\n    const courtElement = $(this);\n    \n    // Extract court information\n    const courtName = courtElement.find('.court-name, .court-title').text().trim() || \n                     courtElement.attr('data-court') || 'Court';\n    \n    const timeSlot = courtElement.find('.time, .slot-time').text().trim() || \n                    courtElement.attr('data-time');\n    \n    const status = courtElement.find('.status, .availability').text().trim().toLowerCase() ||\n                  courtElement.attr('data-status') || '';\n    \n    const date = courtElement.find('.date').text().trim() || \n                courtElement.attr('data-date') || moment().format('YYYY-MM-DD');\n    \n    // Check if court is available (\"Liber\" means available in Romanian)\n    if (status.includes('liber') || status.includes('available') || \n        courtElement.hasClass('available') || courtElement.hasClass('liber')) {\n      \n      // Parse time slot\n      const timeMatch = timeSlot.match(/(\\d{1,2})[:\\.]?(\\d{2})\\s*-\\s*(\\d{1,2})[:\\.]?(\\d{2})/);\n      if (timeMatch) {\n        const startHour = parseInt(timeMatch[1]);\n        const startMinute = parseInt(timeMatch[2] || '0');\n        const endHour = parseInt(timeMatch[3]);\n        const endMinute = parseInt(timeMatch[4] || '0');\n        \n        // Create moment objects for start and end times\n        const slotStart = moment(date).hour(startHour).minute(startMinute);\n        const slotEnd = moment(date).hour(endHour).minute(endMinute);\n        \n        // Only include future time slots\n        if (slotStart.isAfter(currentTime)) {\n          const dayOfWeek = slotStart.day(); // 0 = Sunday, 1 = Monday, etc.\n          const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;\n          \n          availableCourts.push({\n            id: `${courtName.replace(/\\s+/g, '')}-${slotStart.format('YYYY-MM-DD-HH-mm')}`,\n            sport: 'tennis',\n            venue: 'Teren Sud Arena',\n            courtName: courtName,\n            date: slotStart.format('YYYY-MM-DD'),\n            timeSlot: `${slotStart.format('HH:mm')}-${slotEnd.format('HH:mm')}`,\n            startTime: slotStart.toISOString(),\n            endTime: slotEnd.toISOString(),\n            status: 'available',\n            bookingUrl: courtElement.find('a').attr('href') || '',\n            source: 'sudarena',\n            lastChecked: currentTime.toISOString(),\n            dayOfWeek: slotStart.format('dddd'),\n            isWeekend: isWeekend,\n            hour: slotStart.hour()\n          });\n        }\n      }\n    }\n  });\n  \n  // If no specific court elements found, try alternative parsing methods\n  if (availableCourts.length === 0) {\n    // Look for table structures\n    $('table tr, .schedule-row, .booking-row').each(function() {\n      const row = $(this);\n      const cells = row.find('td, .cell, .slot');\n      \n      if (cells.length > 0) {\n        cells.each(function(index) {\n          const cell = $(this);\n          const cellText = cell.text().trim().toLowerCase();\n          \n          if (cellText.includes('liber') || cellText.includes('available')) {\n            // Extract time from header or data attributes\n            const timeHeader = cell.attr('data-time') || \n                             row.find('th').eq(index).text().trim() ||\n                             $('thead th').eq(index).text().trim();\n            \n            if (timeHeader) {\n              const timeMatch = timeHeader.match(/(\\d{1,2})[:\\.]?(\\d{2})/);\n              if (timeMatch) {\n                const hour = parseInt(timeMatch[1]);\n                const minute = parseInt(timeMatch[2] || '0');\n                \n                const slotStart = moment().hour(hour).minute(minute);\n                const slotEnd = moment().hour(hour + 1).minute(minute);\n                \n                if (slotStart.isAfter(currentTime)) {\n                  const dayOfWeek = slotStart.day();\n                  const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;\n                  \n                  availableCourts.push({\n                    id: `court-${index}-${slotStart.format('YYYY-MM-DD-HH-mm')}`,\n                    sport: 'tennis',\n                    venue: 'Teren Sud Arena',\n                    courtName: `Court ${index + 1}`,\n                    date: slotStart.format('YYYY-MM-DD'),\n                    timeSlot: `${slotStart.format('HH:mm')}-${slotEnd.format('HH:mm')}`,\n                    startTime: slotStart.toISOString(),\n                    endTime: slotEnd.toISOString(),\n                    status: 'available',\n                    bookingUrl: '',\n                    source: 'sudarena',\n                    lastChecked: currentTime.toISOString(),\n                    dayOfWeek: slotStart.format('dddd'),\n                    isWeekend: isWeekend,\n                    hour: slotStart.hour()\n                  });\n                }\n              }\n            }\n          }\n        });\n      }\n    });\n  }\n  \n  // Sort results by date and time\n  availableCourts.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));\n  \n  return {\n    courts: availableCourts,\n    totalFound: availableCourts.length,\n    lastUpdated: currentTime.toISOString(),\n    source: 'sudarena',\n    nextCheck: moment().add(30, 'minutes').toISOString()\n  };\n  \n} catch (error) {\n  console.error('Parsing error:', error);\n  return {\n    courts: [],\n    totalFound: 0,\n    lastUpdated: currentTime.toISOString(),\n    source: 'sudarena',\n    error: error.message,\n    nextCheck: moment().add(30, 'minutes').toISOString()\n  };\n}"
      },
      "id": "parse-html",
      "name": "Parse Court Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        600,
        200
      ],
      "notes": "Extracts court availability data from HTML"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition1",
              "leftValue": "={{ $json.totalCourts || $json.totalFound }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-availability",
      "name": "Check If Courts Available",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        800,
        200
      ],
      "notes": "Routes based on whether courts are available"
    },
    {
      "parameters": {
        "jsCode": "// Format court data for Discord message with time filtering\nconst moment = require('moment-timezone');\nmoment.tz.setDefault('Europe/Bucharest');\n\nconst data = $input.first().json;\nconst allCourts = data.courts || [];\n\n// Apply time filtering: weekdays after 6 PM, weekends anytime\nconst filteredCourts = allCourts.filter(court => {\n  // Weekend courts (Saturday=6, Sunday=0) - show any time\n  if (court.isWeekend) {\n    return true;\n  }\n  // Weekday courts - only show after 6 PM (18:00)\n  return court.hour >= 18;\n});\n\nif (filteredCourts.length === 0) {\n  return {\n    hasAvailability: false,\n    message: \"😔 **No Available Courts**\\n\\n📅 **No courts matching your time preferences**\\n📝 Showing: Weekends (anytime) • Weekdays (after 6 PM)\\n⏰ Checked: \" + moment().format('HH:mm DD/MM/YYYY') + \"\\n\\nI'll keep monitoring and notify you when courts become available!\",\n    lastUpdated: data.lastUpdated,\n    nextCheck: data.nextCheck\n  };\n}\n\n// Group filtered courts by date\nconst courtsByDate = {};\nfilteredCourts.forEach(court => {\n  if (!courtsByDate[court.date]) {\n    courtsByDate[court.date] = [];\n  }\n  courtsByDate[court.date].push(court);\n});\n\n// Build Discord message\nlet message = \"🎾 **Tennis Courts Available**\\n\\n\";\nmessage += \"📝 *Showing: Weekends (anytime) • Weekdays (after 6 PM)*\\n\\n\";\n\nObject.keys(courtsByDate).sort().forEach(date => {\n  const dateFormatted = moment(date).format('dddd, DD/MM/YYYY');\n  const isToday = moment(date).isSame(moment(), 'day');\n  const isTomorrow = moment(date).isSame(moment().add(1, 'day'), 'day');\n  \n  let dayLabel = dateFormatted;\n  if (isToday) dayLabel = `Today (${moment(date).format('DD/MM/YYYY')})`;\n  else if (isTomorrow) dayLabel = `Tomorrow (${moment(date).format('DD/MM/YYYY')})`;\n  \n  message += `📅 **${dayLabel}**\\n`;\n  \n  courtsByDate[date].forEach(court => {\n    message += `• ${court.courtName} - ${court.timeSlot} ⚡ Available\\n`;\n  });\n  \n  message += \"\\n\";\n});\n\nmessage += `⏰ Last updated: ${moment(data.lastUpdated).format('HH:mm DD/MM/YYYY')}\\n`;\nmessage += `🔄 Next check: ${moment(data.nextCheck).format('HH:mm')}\\n\\n`;\nmessage += \"React with 📅 to get booking info\";\n\nreturn {\n  hasAvailability: true,\n  message: message,\n  courts: filteredCourts,\n  totalCourts: filteredCourts.length,\n  lastUpdated: data.lastUpdated,\n  nextCheck: data.nextCheck\n};"
      },
      "id": "format-message",
      "name": "Format Discord Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1000,
        200
      ],
      "notes": "Formats court data into Discord message"
    },
    {
      "parameters": {
        "jsCode": "// Parse Discord command and extract parameters\nconst webhookData = $input.first().json;\n\n// Extract command from Discord webhook data\nlet command = '';\nlet parameters = {};\n\n// Handle different Discord webhook formats\nif (webhookData.data && webhookData.data.name) {\n  // Slash command format\n  command = webhookData.data.name;\n  if (webhookData.data.options) {\n    webhookData.data.options.forEach(option => {\n      parameters[option.name] = option.value;\n    });\n  }\n} else if (webhookData.content) {\n  // Message content format (legacy commands)\n  const content = webhookData.content.toLowerCase().trim();\n  if (content.startsWith('!tennis')) {\n    const parts = content.split(' ');\n    if (parts.length > 1) {\n      command = parts[1]; // 'today', 'week', etc.\n      if (parts.length > 2) {\n        parameters.date = parts[2];\n      }\n    }\n  }\n}\n\n// Set default command if none provided\nif (!command) {\n  command = 'today';\n}\n\nreturn {\n  command: command,\n  parameters: parameters,\n  userId: webhookData.member?.user?.id || webhookData.user?.id || 'unknown',\n  userName: webhookData.member?.user?.username || webhookData.user?.username || 'Unknown User',\n  channelId: webhookData.channel_id,\n  guildId: webhookData.guild_id,\n  originalData: webhookData\n};"
      },
      "id": "parse-command",
      "name": "Parse Discord Command",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        400
      ],
      "notes": "Parses incoming Discord commands"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "condition1",
              "leftValue": "={{ $json.command }}",
              "rightValue": "today",
              "operator": {
                "type": "string",
                "operation": "equals",
                "caseSensitive": false
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "route-commands",
      "name": "Route Commands",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [
        600,
        400
      ],
      "notes": "Routes commands to appropriate handlers"
    },
    {
      "parameters": {
        "url": "https://www.sudarena.ro/rezervari",
        "options": {
          "headers": {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
          },
          "timeout": 30000,
          "retry": {
            "enabled": true,
            "maxTries": 3,
            "waitBetweenTries": 2000
          }
        }
      },
      "id": "scrape-on-demand",
      "name": "Scrape Courts (On-Demand)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        800,
        400
      ],
      "notes": "Fetches court data for command responses"
    },
    {
      "parameters": {
        "jsCode": "// Parse HTML for on-demand requests with date filtering\nconst cheerio = require('cheerio');\nconst moment = require('moment-timezone');\n\nmoment.tz.setDefault('Europe/Bucharest');\n\nconst htmlContent = $input.first().json.data;\nconst command = $input.all()[1].json.command;\nconst parameters = $input.all()[1].json.parameters;\n\nconst $ = cheerio.load(htmlContent);\nconst availableCourts = [];\nconst currentTime = moment();\n\n// Determine date range based on command\nlet startDate, endDate;\n\nswitch (command) {\n  case 'today':\n    startDate = moment().startOf('day');\n    endDate = moment().endOf('day');\n    break;\n  case 'week':\n    startDate = moment().startOf('day');\n    endDate = moment().add(7, 'days').endOf('day');\n    break;\n  default:\n    if (parameters.date) {\n      startDate = moment(parameters.date).startOf('day');\n      endDate = moment(parameters.date).endOf('day');\n    } else {\n      startDate = moment().startOf('day');\n      endDate = moment().endOf('day');\n    }\n}\n\n// Parse court availability (same logic as main parser)\ntry {\n  $('.court-slot, .booking-slot, .time-slot').each(function() {\n    const courtElement = $(this);\n    \n    const courtName = courtElement.find('.court-name, .court-title').text().trim() || \n                     courtElement.attr('data-court') || 'Court';\n    \n    const timeSlot = courtElement.find('.time, .slot-time').text().trim() || \n                    courtElement.attr('data-time');\n    \n    const status = courtElement.find('.status, .availability').text().trim().toLowerCase() ||\n                  courtElement.attr('data-status') || '';\n    \n    const date = courtElement.find('.date').text().trim() || \n                courtElement.attr('data-date') || moment().format('YYYY-MM-DD');\n    \n    if (status.includes('liber') || status.includes('available') || \n        courtElement.hasClass('available') || courtElement.hasClass('liber')) {\n      \n      const timeMatch = timeSlot.match(/(\\d{1,2})[:\\.]?(\\d{2})\\s*-\\s*(\\d{1,2})[:\\.]?(\\d{2})/);\n      if (timeMatch) {\n        const startHour = parseInt(timeMatch[1]);\n        const startMinute = parseInt(timeMatch[2] || '0');\n        const endHour = parseInt(timeMatch[3]);\n        const endMinute = parseInt(timeMatch[4] || '0');\n        \n        const slotStart = moment(date).hour(startHour).minute(startMinute);\n        const slotEnd = moment(date).hour(endHour).minute(endMinute);\n        \n        // Check if slot is within requested date range and after current time\n        if (slotStart.isBetween(startDate, endDate, null, '[]') && slotStart.isAfter(currentTime)) {\n          const dayOfWeek = slotStart.day();\n          const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;\n          \n          availableCourts.push({\n            id: `${courtName.replace(/\\s+/g, '')}-${slotStart.format('YYYY-MM-DD-HH-mm')}`,\n            sport: 'tennis',\n            venue: 'Teren Sud Arena',\n            courtName: courtName,\n            date: slotStart.format('YYYY-MM-DD'),\n            timeSlot: `${slotStart.format('HH:mm')}-${slotEnd.format('HH:mm')}`,\n            startTime: slotStart.toISOString(),\n            endTime: slotEnd.toISOString(),\n            status: 'available',\n            bookingUrl: courtElement.find('a').attr('href') || '',\n            source: 'sudarena',\n            lastChecked: currentTime.toISOString(),\n            dayOfWeek: slotStart.format('dddd'),\n            isWeekend: isWeekend,\n            hour: slotStart.hour()\n          });\n        }\n      }\n    }\n  });\n  \n  // Alternative parsing if no courts found\n  if (availableCourts.length === 0) {\n    $('table tr, .schedule-row, .booking-row').each(function() {\n      const row = $(this);\n      const cells = row.find('td, .cell, .slot');\n      \n      if (cells.length > 0) {\n        cells.each(function(index) {\n          const cell = $(this);\n          const cellText = cell.text().trim().toLowerCase();\n          \n          if (cellText.includes('liber') || cellText.includes('available')) {\n            const timeHeader = cell.attr('data-time') || \n                             row.find('th').eq(index).text().trim() ||\n                             $('thead th').eq(index).text().trim();\n            \n            if (timeHeader) {\n              const timeMatch = timeHeader.match(/(\\d{1,2})[:\\.]?(\\d{2})/);\n              if (timeMatch) {\n                const hour = parseInt(timeMatch[1]);\n                const minute = parseInt(timeMatch[2] || '0');\n                \n                const slotStart = moment().hour(hour).minute(minute);\n                const slotEnd = moment().hour(hour + 1).minute(minute);\n                \n                if (slotStart.isBetween(startDate, endDate, null, '[]') && slotStart.isAfter(currentTime)) {\n                  const dayOfWeek = slotStart.day();\n                  const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;\n                  \n                  availableCourts.push({\n                    id: `court-${index}-${slotStart.format('YYYY-MM-DD-HH-mm')}`,\n                    sport: 'tennis',\n                    venue: 'Teren Sud Arena',\n                    courtName: `Court ${index + 1}`,\n                    date: slotStart.format('YYYY-MM-DD'),\n                    timeSlot: `${slotStart.format('HH:mm')}-${slotEnd.format('HH:mm')}`,\n                    startTime: slotStart.toISOString(),\n                    endTime: slotEnd.toISOString(),\n                    status: 'available',\n                    bookingUrl: '',\n                    source: 'sudarena',\n                    lastChecked: currentTime.toISOString(),\n                    dayOfWeek: slotStart.format('dddd'),\n                    isWeekend: isWeekend,\n                    hour: slotStart.hour()\n                  });\n                }\n              }\n            }\n          }\n        });\n      }\n    });\n  }\n  \n  availableCourts.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));\n  \n  return {\n    courts: availableCourts,\n    totalFound: availableCourts.length,\n    lastUpdated: currentTime.toISOString(),\n    source: 'sudarena',\n    command: command,\n    dateRange: {\n      start: startDate.format('YYYY-MM-DD'),\n      end: endDate.format('YYYY-MM-DD')\n    }\n  };\n  \n} catch (error) {\n  console.error('On-demand parsing error:', error);\n  return {\n    courts: [],\n    totalFound: 0,\n    lastUpdated: currentTime.toISOString(),\n    source: 'sudarena',\n    error: error.message,\n    command: command\n  };\n}"
      },
      "id": "parse-on-demand",
      "name": "Parse Court Data (On-Demand)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1000,
        400
      ],
      "notes": "Parses court data for Discord commands"
    },
    {
      "parameters": {
        "url": "={{ $vars.DISCORD_WEBHOOK_URL }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { \"content\": $json.message } }}",
        "options": {
          "headers": {
            "Content-Type": "application/json"
          },
          "timeout": 10000
        }
      },
      "id": "send-notification",
      "name": "Send Discord Notification",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1200,
        200
      ],
      "notes": "Sends availability notifications to Discord"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"type\": 4, \"data\": { \"content\": $json.message } } }}",
        "options": {}
      },
      "id": "discord-response",
      "name": "Discord Command Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1200,
        400
      ],
      "notes": "Responds to Discord slash commands"
    },
    {
      "parameters": {
        "jsCode": "// Error handling and logging\nconst moment = require('moment-timezone');\nmoment.tz.setDefault('Europe/Bucharest');\n\nconst error = $input.first().json;\nconst errorMessage = error.message || 'Unknown error occurred';\nconst errorType = error.name || error.type || 'GenericError';\n\nconsole.error('Tennis Buddy Error:', {\n  type: errorType,\n  message: errorMessage,\n  timestamp: moment().toISOString(),\n  input: error\n});\n\n// Create user-friendly error message\nconst userMessage = \"⚠️ **Service Temporarily Unavailable**\\n\\n\" +\n                   \"I'm having trouble checking court availability right now.\\n\" +\n                   \"Please try again in a few minutes.\\n\\n\" +\n                   `Status: ${errorType}\\n` +\n                   `Time: ${moment().format('HH:mm DD/MM/YYYY')}`;\n\nreturn {\n  error: true,\n  errorType: errorType,\n  errorMessage: errorMessage,\n  userMessage: userMessage,\n  timestamp: moment().toISOString(),\n  shouldRetry: !errorType.includes('Auth') && !errorType.includes('Permission')\n};"
      },
      "id": "error-handler",
      "name": "Error Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1000,
        600
      ],
      "notes": "Handles and logs errors gracefully"
    },
    {
      "parameters": {
        "url": "={{ $vars.DISCORD_WEBHOOK_URL }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { \"content\": $json.userMessage } }}",
        "options": {
          "headers": {
            "Content-Type": "application/json"
          },
          "timeout": 10000
        }
      },
      "id": "send-error-notification",
      "name": "Send Error Notification",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1200,
        600
      ],
      "notes": "Sends error notifications to Discord"
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Scrape Tennis Courts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Discord Commands Webhook": {
      "main": [
        [
          {
            "node": "Parse Discord Command",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Scrape Tennis Courts": {
      "main": [
        [
          {
            "node": "Parse Court Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Court Data": {
      "main": [
        [
          {
            "node": "Check If Courts Available",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check If Courts Available": {
      "main": [
        [
          {
            "node": "Format Discord Message",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Format Discord Message": {
      "main": [
        [
          {
            "node": "Send Discord Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Discord Command": {
      "main": [
        [
          {
            "node": "Route Commands",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Commands": {
      "main": [
        [
          {
            "node": "Scrape Courts (On-Demand)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Scrape Courts (On-Demand)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Scrape Courts (On-Demand)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Scrape Courts (On-Demand)": {
      "main": [
        [
          {
            "node": "Parse Court Data (On-Demand)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Court Data (On-Demand)": {
      "main": [
        [
          {
            "node": "Format Discord Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": {
      "errorWorkflowId": "error-handler"
    }
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2024-01-15T10:00:00.000Z",
      "updatedAt": "2024-01-15T10:00:00.000Z",
      "id": "tennis-monitoring",
      "name": "Tennis Monitoring"
    },
    {
      "createdAt": "2024-01-15T10:00:00.000Z",
      "updatedAt": "2024-01-15T10:00:00.000Z",
      "id": "discord-bot",
      "name": "Discord Bot"
    },
    {
      "createdAt": "2024-01-15T10:00:00.000Z",
      "updatedAt": "2024-01-15T10:00:00.000Z",
      "id": "web-scraping",
      "name": "Web Scraping"
    }
  ],
  "triggerCount": 2,
  "updatedAt": "2024-01-15T10:00:00.000Z",
  "versionId": "1"
}